Commits in this patch:
----------------------

  1a94011645c8e3c31dd950dfc0fc71b2ad47320f
  ipv6: raw: Deduct extension header length in rawv6_push_pending_frames



ipv6: raw: Deduct extension header length in rawv6_push_pending_frames

jira LE-556
cve CVE-2023-0394
commit cb3e9864cdbe35ff6378966660edbcbac955fe17

The total cork length created by ip6_append_data includes extension
headers, so we must exclude them when comparing them against the
IPV6_CHECKSUM offset which does not include extension headers.

    Reported-by: Kyle Zeng <zengyhkyle@gmail.com>
    Fixes: 357b40a18b04 ("[IPV6]: IPV6_CHECKSUM socket option can corrupt kernel memory")
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    (cherry picked from commit cb3e9864cdbe35ff6378966660edbcbac955fe17)

Signed-off-by: David Gomez <dgomez@ciq.com>
diff --git a/net/ipv6/raw.c b/net/ipv6/raw.c
index 05c2ee29fa59..2081020eb2c1 100644
--- a/net/ipv6/raw.c
+++ b/net/ipv6/raw.c
@@ -544,6 +544,7 @@ static int rawv6_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,
 static int rawv6_push_pending_frames(struct sock *sk, struct flowi6 *fl6,
 				     struct raw6_sock *rp)
 {
+	struct ipv6_txoptions *opt;
 	struct sk_buff *skb;
 	int err = 0;
 	int offset;
@@ -561,6 +562,9 @@ static int rawv6_push_pending_frames(struct sock *sk, struct flowi6 *fl6,
 
 	offset = rp->offset;
 	total_len = inet_sk(sk)->cork.base.length;
+	opt = inet6_sk(sk)->cork.opt;
+	total_len -= opt ? opt->opt_flen : 0;
+
 	if (offset >= total_len - 1) {
 		err = -EINVAL;
 		ip6_flush_pending_frames(sk);
-- 
2.39.3

