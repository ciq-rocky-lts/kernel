Commits in this patch:
----------------------

  02908f4bc3fe81d58daf8fd11020d55223eae243
  net: mpls: fix stale pointer if allocation fails during device rename



net: mpls: fix stale pointer if allocation fails during device rename

jira LE-556
cve CVE-2023-26545
commit fda6c89fe3d9aca073495a664e1d5aea28cd4377

lianhui reports that when MPLS fails to register the sysctl table
under new location (during device rename) the old pointers won't
get overwritten and may be freed again (double free).

Handle this gracefully. The best option would be unregistering
the MPLS from the device completely on failure, but unfortunately
mpls_ifdown() can fail. So failing fully is also unreliable.

Another option is to register the new table first then only
remove old one if the new one succeeds. That requires more
code, changes order of notifications and two tables may be
visible at the same time.

sysctl point is not used in the rest of the code - set to NULL
on failures and skip unregister if already NULL.

    Reported-by: lianhui tang <bluetlh@gmail.com>
    Fixes: 0fae3bf018d9 ("mpls: handle device renames for per-device sysctls")
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    (cherry picked from commit fda6c89fe3d9aca073495a664e1d5aea28cd4377)

Signed-off-by: David Gomez <dgomez@ciq.com>
diff --git a/net/mpls/af_mpls.c b/net/mpls/af_mpls.c
index 6dd921fccc7d..6f903a444da4 100644
--- a/net/mpls/af_mpls.c
+++ b/net/mpls/af_mpls.c
@@ -1429,6 +1429,7 @@ static int mpls_dev_sysctl_register(struct net_device *dev,
 free:
 	kfree(table);
 out:
+	mdev->sysctl = NULL;
 	return -ENOBUFS;
 }
 
@@ -1438,6 +1439,9 @@ static void mpls_dev_sysctl_unregister(struct net_device *dev,
 	struct net *net = dev_net(dev);
 	struct ctl_table *table;
 
+	if (!mdev->sysctl)
+		return;
+
 	table = mdev->sysctl->ctl_table_arg;
 	unregister_net_sysctl_table(mdev->sysctl);
 	kfree(table);
-- 
2.39.3

